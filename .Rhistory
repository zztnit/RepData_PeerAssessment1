do.call(rbind, X)
?do.call
names(Y)[3:5] <- paste0("choice.", 1:3)
Z <- reshape(Y, direction="long", varying=3:5)
View(Z)
?reshape
View(Z)
colnames(Z)[3:4] <- c("choice.no",  "choice")
rownames(Z) <- NULL
Z <- Z[, c(1, 4, 3, 2)]
View(Z)
edges <- as.matrix(Z[, 1:2])
g <- graph.data.frame(edges, directed=TRUE)
str(g)
V(g)$label <- V(g)$name
SUMS <- data.frame(table(Z$choice))
SUMS$Var1 <- as.character(SUMS$Var1)
SUMS <- SUMS[order(as.character(SUMS$Var1)), ]
SUMS$Freq <- as.integer(SUMS$Freq)
label.size <- 2
V(g)$label.cex <- log(scale(SUMS$Freq) + max(abs(scale(SUMS$Freq)))+ label.size)
#Color edges that are reciprocal red
x <- t(apply(edges, 1, sort))
x <- paste0(x[, 1], x[, 2])
y <- x[duplicated(x)]
COLS <- ifelse(x %in% y, "red", "gray40")
E(g)$color <- COLS
#reverse score the choices.no and weight
E(g)$width <- (4 - Z$choice.no)*2
#color vertex based on sex
V(g)$gender <- Y$sex
V(g)$color <- ifelse(V(g)$gender==0, "pink", "lightblue")
#plot it
opar <- par()$mar; par(mar=rep(0, 4)) #Give the graph lots of room
plot.igraph(g, layout=layout.auto(g))
par(mar=opar)
g <- graph.ring(10)
str(g)
V(g)$age <- sample(20:78, vcount(g), replace=TRUE)
V
V(g)
V(g)$age
V(g)$agecat <- cut(V(g)$age, breaks = c(20,35,50,65,78))
V(g)$size <- c(10,15,20,25)[ V(g)$agecat ]
plot(g, layout=layout.circle)
demo(package="igraph")
demo(community, package="igraph")
help(package="igraph")
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
perfect <- c(rep(1,10), rep(2,10), rep(3,10))
modularity(mod, rep(1, 30))
modularity(mod, perfect)
karate <- make_graph("Zachary")
karate$layout <- layout_with_kk(karate, niter=1000)
pause()
fc <- cluster_fast_greedy(karate)
memb <- membership(fc)
plot(karate, vertex.color=memb)
pref.mat <- matrix(0, 16, 16)
pref.mat[1:4,1:4] <- pref.mat[5:8,5:8] <-
pref.mat[9:12,9:12] <- pref.mat[13:16,13:16] <- 7.5/127
View(pref.mat)
pref.mat[ pref.mat==0 ] <- 5/(3*128)
diag(pref.mat) <- diag(pref.mat) + 10/31
G <- sample_pref(128*4, types=16, pref.matrix=pref.mat)
sc1 <- cluster_spinglass(G, spins=4, gamma=1.0)
sc2.2 <- cluster_spinglass(G, spins=16, gamma=2.2)
if (require(Matrix)) {
myimage <- function(...) image(Matrix(...))
} else {
myimage <- image
}
A <- as_adj(G)
myimage(A)
myimage(A[ord1,ord1])
ord2.2 <- order(membership(sc2.2))
myimage(A[ord2.2,ord2.2])
myimage(A[ord,ord])
communities <- list()
ebc <- cluster_edge_betweenness(karate)
communities$`Edge betweenness` <- ebc
fc <- cluster_fast_greedy(karate)
communities$`Fast greedy` <- fc
lec <- cluster_leading_eigen(karate)
communities$`Leading eigenvector` <- lec
sc <- cluster_spinglass(karate, spins=10)
communities$`Spinglass` <- sc
### cluster_walktrap
wt <- cluster_walktrap(karate)
communities$`Walktrap` <- wt
labprop <- cluster_label_prop(karate)
communities$`Label propagation` <- labprop
layout(rbind(1:3, 4:6))
coords <- layout_with_kk(karate)
lapply(seq_along(communities), function(x) {
m <- modularity(communities[[x]])
par(mar=c(1,1,3,1))
plot(communities[[x]], karate, layout=coords,
main=paste(names(communities)[x], "\n",
"Modularity:", round(m, 3)))
})
clq <- cliques(graph, min=k, max=k)
edges <- c()
for (i in seq(along=clq)) {
for (j in seq(along=clq)) {
if ( length(unique(c(clq[[i]],
clq[[j]]))) == k+1 ) {
edges <- c(edges, c(i,j))
}
}
}
clq.graph <- simplify(graph(edges))
V(clq.graph)$name <-
seq(length=vcount(clq.graph))
comps <- decompose(clq.graph)
}
}
clq.graph <- simplify(graph(edges))
V(clq.graph)$name <-
seq(length=vcount(clq.graph))
comps <- decompose(clq.graph)
lapply(comps, function(x) {
unique(unlist(clq[ V(x)$name ]))
})
}
### Apply it to a graph, this is the example graph from
##  the original publication
g <- graph_from_literal(A-B:F:C:E:D, B-A:D:C:E:F:G, C-A:B:F:E:D, D-A:B:C:F:E,
E-D:A:C:B:F:V:W:U, F-H:B:A:C:D:E, G-B:J:K:L:H,
H-F:G:I:J:K:L, I-J:L:H, J-I:G:H:L, K-G:H:L:M,
L-H:G:I:J:K:M, M-K:L:Q:R:S:P:O:N, N-M:Q:R:P:S:O,
O-N:M:P, P-Q:M:N:O:S, Q-M:N:P:V:U:W:R, R-M:N:V:W:Q,
S-N:P:M:U:W:T, T-S:V:W:U, U-E:V:Q:S:W:T,
V-E:U:W:T:R:Q, W-U:E:V:Q:R:S:T)
### Hand-made layout to make it look like the original in the paper
lay <- c(387.0763, 306.6947, 354.0305, 421.0153, 483.5344, 512.1145,
148.6107, 392.4351, 524.6183, 541.5878, 240.6031, 20,
65.54962, 228.0992, 61.9771, 152.1832, 334.3817, 371.8931,
421.9084, 265.6107, 106.6336, 57.51145, 605, 20, 124.8780,
273.6585, 160.2439, 241.9512, 132.1951, 123.6585, 343.1707,
465.1220, 317.561, 216.3415, 226.0976, 343.1707, 306.5854,
123.6585, 360.2439, 444.3902, 532.1951, 720, 571.2195,
639.5122, 505.3659, 644.3902)
lay <- matrix(lay, nc=2)
lay[,2] <- max(lay[,2])-lay[,2]
### Take a look at it
layout(1)
plot(g, layout=lay, vertex.label=V(g)$name)
res <- clique.community(g, k=4)
### Paint them to different colors
colbar <- rainbow( length(res)+1 )
for (i in seq(along=res)) {
V(g)[ res[[i]] ]$color <- colbar[i+1]
}
### Paint the vertices in multiple communities to red
V(g)[ unlist(res)[ duplicated(unlist(res)) ] ]$color <- "red"
### Plot with the new colors
plot(g, layout=lay, vertex.label=V(g)$name)
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
perfect <- c(rep(1,10), rep(2,10), rep(3,10))
modularity(mod, perfect)
### Modularity of the trivial partition, quite bad
modularity(mod, rep(1, 30))
### Modularity of a good partition with two communities
modularity(mod, c(rep(1, 10), rep(2,20)))
#[1] 0.4444444
karate <- make_graph("Zachary")
karate$layout <- layout_with_kk(karate, niter=1000)
fc <- cluster_fast_greedy(karate)
memb <- membership(fc)
plot(karate, vertex.color=memb)
plot(fc, karate)
str(fc)
q()
library(dplyr)
help(package= "dplyr")
demo(dplyr)
demo()
demo("dplyr")
help(package= "dplyr")
summarise(flights,  delay = mean(dep_delay, na.rm = TRUE))
?summarize_each
summarise_each(iris, funs(mean))
?summarise_each
str(iris)
summarise_each_(iris, funs(max), names(iris)[-5])
summarise_each_(iris, funs(max), list(quote(-Species)))
by_species <- iris %>% group_by(Species)
by_species %>% summarise_each(funs(length))
by_species %>% summarise_each(funs(min, max))
by_species %>% mutate_each(funs(half = . / 2))
head(iris)
library(UsingR); data(galton); library(ggplot2); library(reshape2)
install.packages("UsingR")
library(UsingR); data(galton); library(ggplot2); library(reshape2)
longGalton <- melt(galton, measure.vars = c("child", "parent"))
View(galton)
View(longGalton)
library(tidyr)
long <- gather(galton, variable, value)
g <- ggplot(longGalton, aes(x = value)) + geom_histogram(aes(y = ..density.., fill = variable), binwidth=1, color = "black") + geom_density(size = 2)
g <- g + facet_grid(. ~ variable)
g
library(manipulate)
install.packages("manipulate")
library(manipulate)
myHist <- function(mu){ g <- ggplot(galton, aes(x = child)) g <- g + geom_histogram(fill = "salmon", binwidth=1, aes(y = ..density..), color = "black") g <- g + geom_density(size = 2) g <- g + geom_vline(xintercept = mu, size = 2) mse <- round(mean((galton$child - mu)^2), 3) g <- g + labs(title = paste('mu = ', mu, ' MSE = ', mse)) g } manipulate(myHist(mu), mu = slider(62, 74, step = 0.5))
myHist <- function(mu){
g <- ggplot(galton, aes(x = child))
g <- g + geom_histogram(fill = "salmon", binwidth=1, aes(y = ..density..), color = "black")
g <- g + geom_density(size = 2)
g <- g + geom_vline(xintercept = mu, size = 2)
mse <- round(mean((galton$child - mu)^2), 3)
g <- g + labs(title = paste('mu = ', mu, ' MSE = ', mse))
g
}
manipulate(myHist(mu), mu = slider(62, 74, step = 0.5))
p = seq(0 , 1, length = 1000)
y = p * (1 - p)
plot(p, y, type = "l", lwd = 3, frame = FALSE)
nosim <- 1000
n <- 10
## simulate nosim averages of 10 standard normals
sd(apply(matrix(rnorm(nosim * n), nosim), 1, mean))
1 / sqrt(n)
m <- matrix(rnorm(nosim * n), nosim)
mean <- apply(m, 1, mean)
nosim <- 1000
n <- 10
sd(apply(matrix(runif(nosim * n), nosim), 1, mean))
#[1] 0.09017
1 / sqrt(12 * n)
nosim <- 1000
n <- 10
sd(apply(matrix(rpois(nosim * n, 4), nosim), 1, mean))
#[1] 0.6219
2 / sqrt(n)
nosim <- 1000
n <- 10
sd(apply(matrix(sample(0 : 1, nosim * n, replace = TRUE), nosim), 1, mean))
#[1] 0.1587
1 / (2 * sqrt(n))
sd(apply(matrix(sample(0 : 1, nosim * n, replace = TRUE), nosim), 1, mean))
#[1] 0.1587
1 / (2 * sqrt(n))
library(manipulate)
myHist <- function(mu){
g <- ggplot(galton, aes(x = child))
g <- g + geom_histogram(fill = "salmon", binwidth=1, aes(y = ..density..), color = "black")
g <- g + geom_density(size = 2)
g <- g + geom_vline(xintercept = mu, size = 2)
mse <- round(mean((galton$child - mu)^2), 3)
g <- g + labs(title = paste('mu = ', mu, ' MSE = ', mse))
g
}
manipulate(myHist(mu), mu = slider(62, 74, step = 0.5))
x <- c(-0.5, 0, 1, 1, 1.5)
y <- c(0, 0, 2, 0, 0)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
pbeta(0.75, 2, 1)
1.5 * 0.75/2
qunif(0.75)
?qunif
1/(1+1.12/0.75)
library(kernlab)
install.packages("kernlab")
library(kernlab)
data(spam)
str(spam[, 1:5])
set.seed(3435)
trainIndicator = rbinom(4601, size = 1, prob = 0.5)
table(trainIndicator)
?rbinom
idx <- runif(4601)>0.5
table(idx)
idx <- runif(4601)>=0.5
table(idx)
trainSpam  <-  spam[trainIndicator == 1, ]
testSpam <-  spam[trainIndicator == 0, ]
head(names(trainSpam), 20)
head(trainSpam[, 1:10])
table(trainSpam$type)
boxplot(capitalAve ~ type, data = trainSpam)
boxplot(log10(capitalAve + 1) ~ type, data = trainSpam)
pairs(log10(trainSpam[, 1:4] + 1))
hCluster = hclust(dist(t(trainSpam[, 1:57])))
plot(hCluster)
hClusterUpdated = hclust(dist(t(log10(trainSpam[, 1:55] + 1))))
plot(hClusterUpdated)
trainSpam$numType = as.numeric(trainSpam$type) - 1
costFunction = function(x, y) sum(x != (y > 0.5))
cvError = rep(NA, 55)
library(boot)
for (i in 1:55) {
lmFormula = reformulate(names(trainSpam)[i], respon\
se = "numType")
glmFit = glm(lmFormula, family = "binomial", data =\
trainSpam)
cvError[i] = cv.glm(trainSpam, glmFit, costFunction\
, 2)$delta[2]
for (i in 1:55) {
lmFormula = reformulate(names(trainSpam)[i], response = "numType")
glmFit = glm(lmFormula, family = "binomial", data = trainSpam)
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
## Which predictor has minimum cross-validated error?
names(trainSpam)[which.min(cvError)]
predictionModel = glm(numType ~ charDollar, family = "binomial", data = trainSpam)
predictionTest = predict(predictionModel, testSpam)
predictedSpam = rep("nonspam", dim(testSpam)[1])
predictedSpam[predictionModel$fitted > 0.5] = "spam"
table(predictedSpam, testSpam$type)
(61 + 458)/(1346 + 458 + 61 + 449)
a
i
q()
getwd()
setwd("./GitHub/RepData_PeerAssessment1")
getwd()
df <- read.csv(csvfile, stringsAsFactors = FALSE)
csvfile <- "activity.csv"
#unzip(zipfile)
df <- read.csv(csvfile, stringsAsFactors = FALSE)
df <- transform(df, date = as.Date(date))
summary(df$steps)
library(dplyr)
stepsdf <- df %>% group_by(date) %>% summarise( steps_per_day=sum(steps))
hist(stepsdf$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
mean_steps <- mean(stepsdf$steps_per_day, na.rm = TRUE)
median_steps <- median(stepsdf$steps_per_day, na.rm = TRUE)
stepsIn5min <-  df%>% group_by( interval) %>% summarise( steps_per_interval= mean( steps, na.rm = TRUE ))
title ="Time series of  the average number of steps taken\n in each 5-minute interval"
xlab = "Time intervals"; ylab = "The average number of steps"
plot( stepsIn5min$interval, stepsIn5min$steps_per_interval, type = "l",
main = title, xlab = xlab, ylab = ylab )
maxsteps <- max(stepsIn5min$steps_per_interval)
intervalMaxSteps <- stepsIn5min$interval[which.max(stepsIn5min$steps_per_interval)]
starttime <- intervalMaxSteps/60
n_na <- sum(is.na(df$steps))
newdf <- df
stepsvec <- df$steps
datevec <- df$date
intervalvec <- df$interval
interval <- stepsIn5min$interval
for (i in interval) {
newdf$steps[intervalvec == i & is.na(stepsvec)] <- stepsIn5min$steps_per_interval[stepsIn5min$interval==i]
}
stepsdf2 <- newdf %>% group_by(date) %>% summarise( steps_per_day=sum(steps))
hist(stepsdf2$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
mean_steps2 <- mean(stepsdf2$steps_per_day)
median_steps2 <- median(stepsdf2$steps_per_day)
#Do these values differ from the estimates from the first part of the assignment? What is the impact of imputing missing data on the estimates of the total daily number of steps?
diff_mean_steps <- mean_steps2-mean_steps
diff_median_steps <- median_steps2-median_steps
x <- head(newdf$date)
x
unclass(x)
weekdays(x)
unclass(weekdays(x))
str(weekdays(x))
y <- as.POSIXct(x)
unclass(y)
y <- as.POSIXlt(x)
unclass(y)
y
y$wday
weekdayvec <- weekdays(newdf$date, abbreviate = TRUE)
x <- tail(weekdays)
x
x <- tail(weekdayvec)
x
y <- as.POSIXlt(x)
y <- as.POSIXlt(x)
x1 <- tail(newdf$date)
x1 <- as.POSIXlt(tail(newdf$date))
x1 <- as.POSIXlt(tail(newdf$date))$wday
x1
as.POSIXlt("2012-10-07")$wday
as.POSIXlt("2012-10-06")$wday
as.POSIXlt("2012-10-08")$wday
newdf %>% mutate(weekend = as.POSIXlt(date) %in% c(0,6))
newdf2 <- newdf %>% mutate(weekend = as.POSIXlt(date) %in% c(0,6))
workdf <- filter(newdf2, weekend==FALSE)
weekenddf<- filter(newdf2, weekend== TRUE)
table(newdf2$weekend)
newdf2 <- newdf %>% mutate(weekend = as.POSIXlt(date)$wday %in% c(0,6))
table(newdf2$weekend)
workdf <- filter(newdf2, weekend==FALSE)
weekenddf<- filter(newdf2, weekend== TRUE)
meanSteps <- function(df){
stepsIn5min <-  df%>% group_by( interval) %>% summarise( steps_per_interval= mean( steps, na.rm = TRUE ))
stepsIn5min
}
workday <- meanSteps(workdf)
weekend <- meanSteps(weekenddf)
uniondf <- rbind(workday, weekend)
head(uniondf)
workday <- transform(meanSteps(workdf), type = "workday")
weekend <- transform(meanSteps(weekenddf), type ="weekend")
uniondf <- rbind(workday, weekend)
head(uniondf)
tail(uniondf)
library(ggplot2)
library("ggplot2")
g <- ggplot(uniondf, aes(interval, steps_per_interval))
g + geom_point() + geom_smooth() +facet_grid( type ~ .)
g + geom_point() + geom_line() +facet_grid( type ~ .)
g + geom_point() + geom_line() +facet_grid( type ~ .)
g + geom_line() +facet_grid( type ~ .)
g + geom_line( size=1 ) +facet_grid( type ~ .)
g + geom_line( size= 0.8 ) +facet_grid( type ~ .)
g + geom_line( size= 0.8 ) +facet_grid( type ~ .)
g + geom_line( size= 0.6 ) +facet_grid( type ~ .)
g + geom_line( size= 0.8 ) +facet_grid( type ~ .)
g + geom_line( size= 0.8 ) +facet_grid( type ~ .) +
labs(title=title, x=xlab, y=ylab)
288*5/60
workday$interval
2355/60
2360/60
288*5
288*5/60
title ="Time series of  the average number of steps taken\n in each 5-minute interval"
xlab = "Time intervals"; ylab = "The number of steps"
g <- ggplot(uniondf, aes(interval, steps_per_interval))
g + geom_line( size= 0.8 ) +facet_grid( type ~ .) +
labs(title=title, x=xlab, y=ylab)
csvfile <- "activity.csv"
df <- read.csv(csvfile, stringsAsFactors = FALSE)
df <- transform(df, date = as.Date(date))
summary(df$steps)
stepsdf <- df %>% group_by(date) %>% summarise( steps_per_day = sum(steps))
library(dplyr,"ggplot2")
stepsPerDay <- df %>% group_by(date) %>% summarise( steps_per_day = sum(steps))
csvfile <- "activity.csv"
df <- read.csv(csvfile, stringsAsFactors = FALSE)
df <- transform(df, date = as.Date(date))
summary(df$steps)
stepsPerDay <- df %>% group_by(date) %>% summarise( steps_per_day = sum(steps))
g <- ggplot(stepsPerDay, aes( steps_per_day ))
g + geom_histogram( )
hist(stepsdf$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
hist(stepsPerDay$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
title = "Histogram of the total number of steps taken each day"
xlab = "The total number of steps taken each day";ylab ="Frequency"
g <- ggplot(stepsPerDay, aes( steps_per_day ))
g + geom_histogram( ) + labs(title=title, x=xlab, y=ylab)
g <- ggplot(stepsPerDay, aes( steps_per_day ))
g + geom_histogram( ) + labs(title=title, x=xlab, y=ylab)
hist(stepsPerDay$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
g + geom_histogram( binwidth = 5000 ) + labs(title=title, x=xlab, y=ylab)
g + geom_histogram( binwidth = 5000 ) + labs(title=title, x=xlab, y=ylab)+theme_bw()
g + geom_histogram( binwidth = 5000 ) + labs(title=title, x=xlab, y=ylab)+theme_grey()
mean_steps <- mean(stepsdf$steps_per_day, na.rm = TRUE)
mean_steps <- mean(stepsPerDay$steps_per_day, na.rm = TRUE)
median_steps <- median(stepsPerDay$steps_per_day, na.rm = TRUE)
meanSteps <- function(df){
stepsIn5min <-  df%>% group_by( interval) %>% summarise( steps_per_interval= mean( steps, na.rm = TRUE ))
stepsIn5min
}
stepsIn5min <-  meanSteps( df )
title ="Time series of  the average number of steps taken\n in each 5-minute interval"
xlab = "Time intervals"; ylab = "The number of steps"
g <- ggplot(stepsIn5min, aes( interval, steps_per_interval ))
g + geom_line( size = 0.8 ) + labs(title=title, x=xlab, y=ylab)+theme_grey()
plot( stepsIn5min$interval, stepsIn5min$steps_per_interval, type = "l",
main = title, xlab = xlab, ylab = ylab )
maxsteps <- max(stepsIn5min$steps_per_interval)
intervalMaxSteps <- stepsIn5min$interval[which.max(stepsIn5min$steps_per_interval)]
n_na <- sum(is.na(df$steps))
newdf <- df
stepsvec <- df$steps
datevec <- df$date
intervalvec <- df$interval
interval <- stepsIn5min$interval
for (i in interval) {
newdf$steps[intervalvec == i & is.na(stepsvec)] <- stepsIn5min$steps_per_interval[stepsIn5min$interval==i]
}
stepsPerDay2 <- newdf %>% group_by(date) %>% summarise( steps_per_day=sum(steps))
hist(stepsPerDay2$steps_per_day, main = "Histogram of the total number of steps taken each day",
xlab = "The total number of steps taken each day")
stepsPerDay2 <- newdf %>% group_by(date) %>% summarise( steps_per_day=sum(steps))
stepsPerDay2 <- newdf %>% group_by(date) %>% summarise( steps_per_day=sum(steps))
g <- ggplot(stepsPerDay2, aes( steps_per_day ))
g + geom_histogram( binwidth = 5000 ) + labs(title=title, x=xlab, y=ylab)+theme_grey()
title = "Histogram of the total number of steps taken each day"
xlab = "Total number of steps taken each day"; ylab = "Frequency"
g <- ggplot(stepsPerDay2, aes( steps_per_day ))
g + geom_histogram( binwidth = 5000 ) + labs(title=title, x=xlab, y=ylab)+theme_grey()
mean_steps2 <- mean(stepsPerDay2$steps_per_day)
median_steps2 <- median(stepsPerDay2$steps_per_day)
diff_mean_steps <- mean_steps2-mean_steps
diff_median_steps <- median_steps2-median_steps
newdf2 <- newdf %>% mutate(weekend = as.POSIXlt(date)$wday %in% c(0,6))
workdaydf <- filter(newdf2, weekend==FALSE)
weekenddf<- filter(newdf2, weekend== TRUE)
workday <- transform(meanSteps(workdaydf), type = "workday")
weekend <- transform(meanSteps(weekenddf), type ="weekend")
uniondf <- rbind(workday, weekend)
uniondf <- rbind(workday, weekend)
title ="Time series of  the average number of steps taken\n in each 5-minute interval"
xlab = "Time intervals"; ylab = "Number of steps"
g <- ggplot(uniondf, aes(interval, steps_per_interval))
g + geom_line( size= 0.8 ) +facet_grid( type ~ .) +
labs(title=title, x=xlab, y=ylab)
q()
